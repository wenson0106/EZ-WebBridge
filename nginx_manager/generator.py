import os
from collections import defaultdict


class NginxConfigGenerator:
    """Generates nginx .conf files from service definitions."""

    def __init__(self, output_dir):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def generate_config(self, domain, services):
        """Generate nginx config files for a domain and its services.
        
        Groups services by their effective server_name (base domain or subdomain),
        and generates one server block per unique server_name.
        
        Args:
            domain: Domain model instance
            services: List of Service model instances
            
        Returns:
            dict with 'files' (list of generated file paths) and 'errors' (list of error messages)
        """
        results = {'files': [], 'errors': []}

        # Group services by effective server_name
        server_groups = defaultdict(list)

        for svc in services:
            if not svc.enabled:
                continue
            if svc.subdomain:
                server_name = f"{svc.subdomain}.{domain.domain_name}"
            else:
                server_name = domain.domain_name
            server_groups[server_name].append(svc)

        if not server_groups:
            results['errors'].append('No enabled services to configure.')
            return results

        # Generate one config file per domain (contains all server blocks)
        config_content = self._build_config(domain, server_groups)
        
        # Write to file
        safe_name = domain.domain_name.replace('.', '_')
        filename = f"{safe_name}.conf"
        filepath = os.path.join(self.output_dir, filename)

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(config_content)
            results['files'].append(filepath)
        except IOError as e:
            results['errors'].append(f'Failed to write {filepath}: {str(e)}')

        return results

    def _build_config(self, domain, server_groups):
        """Build the full nginx config string."""
        blocks = []
        blocks.append(f"# Auto-generated nginx config for {domain.domain_name}")
        blocks.append(f"# Generated by Nginx Proxy Manager")
        blocks.append("")

        for server_name in sorted(server_groups.keys()):
            services = server_groups[server_name]
            block = self._build_server_block(server_name, services)
            blocks.append(block)

        return '\n'.join(blocks)

    def _build_server_block(self, server_name, services):
        """Build a single server { } block."""
        lines = []
        lines.append(f"server {{")
        lines.append(f"    listen 80;")
        lines.append(f"    server_name {server_name};")
        lines.append(f"")
        lines.append(f"    # Global proxy settings")
        lines.append(f"    client_max_body_size 0;")
        lines.append(f"    proxy_buffering off;")
        lines.append(f"    proxy_request_buffering off;")
        lines.append(f"")

        for svc in services:
            location_block = self._build_location_block(svc)
            lines.append(location_block)
            lines.append("")

        lines.append(f"}}")
        lines.append("")
        return '\n'.join(lines)

    def _build_location_block(self, service):
        """Build a location { } block for a service.
        
        Key design: 
        - location /path/ { proxy_pass http://internal:port/; }
        - The trailing slash on both sides ensures correct path rewriting.
        - e.g. /website/ -> http://192.168.50.243:5000/
        - So /website/login -> http://192.168.50.243:5000/login
        """
        path = service.path_prefix
        # Ensure path starts and ends with /
        if not path.startswith('/'):
            path = '/' + path
        if not path.endswith('/'):
            path = path + '/'

        internal = service.internal_address
        # Ensure internal address has http:// and trailing /
        if not internal.startswith('http'):
            internal = f"http://{internal}"
        if not internal.endswith('/'):
            internal = internal + '/'

        desc = f"    # {service.description}" if service.description else f"    # Service ID: {service.id}"

        lines = [
            desc,
            f"    location {path} {{",
            f"        proxy_pass {internal};",
            f"",
            f"        # Standard proxy headers",
            f"        proxy_set_header Host $host;",
            f"        proxy_set_header X-Real-IP $remote_addr;",
            f"        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;",
            f"        proxy_set_header X-Forwarded-Proto $scheme;",
            f"        proxy_set_header X-Forwarded-Host $host;",
            f"        proxy_set_header X-Forwarded-Port $server_port;",
            f"",
            f"        # WebSocket support",
            f"        proxy_http_version 1.1;",
            f"        proxy_set_header Upgrade $http_upgrade;",
            f"        proxy_set_header Connection \"upgrade\";",
            f"",
            f"        # Timeout settings",
            f"        proxy_connect_timeout 86400s;",
            f"        proxy_read_timeout 86400s;",
            f"        proxy_send_timeout 86400s;",
            f"",
            f"        # Disable compression so sub_filter works",
            f"        proxy_set_header Accept-Encoding \"\";",
            f"",
            f"        # Path rewriting (Fixes static resources 404s)",
            f"        # Rewrites Content-Type: text/html href=\"/foo\" -> href=\"{path}foo\"",
            f"        sub_filter_types text/html text/css text/javascript application/javascript;",
            f"        sub_filter_once off;",
            f"        sub_filter 'href=\"/' 'href=\"{path}';",
            f"        sub_filter 'src=\"/' 'src=\"{path}';",
            f"        sub_filter 'action=\"/' 'action=\"{path}';",
            f"",
            f"        # Rewrite Location headers (Fixes redirects)",
            f"        proxy_redirect / {path};",
            f"    }}",
        ]
        return '\n'.join(lines)

    def remove_config(self, domain_name):
        """Remove the config file for a domain."""
        safe_name = domain_name.replace('.', '_')
        filename = f"{safe_name}.conf"
        filepath = os.path.join(self.output_dir, filename)
        if os.path.exists(filepath):
            os.remove(filepath)
            return True
        return False
