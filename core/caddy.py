"""
Caddy Manager for EZ-WebBridge.
Handles downloading, starting, stopping Caddy and generating Caddyfiles.
"""

import os
import stat
import subprocess
import threading
import time
import urllib.request
import zipfile

from core.detector import is_windows

BASE_DIR = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
BIN_DIR  = os.path.join(BASE_DIR, 'bin')
CADDY_GENERATED_DIR = os.path.join(BASE_DIR, 'generated_configs', 'caddy')
CADDYFILE_PATH = os.path.join(CADDY_GENERATED_DIR, 'Caddyfile')

def _caddy_exe_name():
    return 'caddy.exe' if is_windows() else 'caddy'

def _caddy_download_url():
    """Returns the official Caddy download URL for this platform."""
    import platform
    arch_map = {'AMD64': 'amd64', 'x86_64': 'amd64', 'ARM64': 'arm64', 'aarch64': 'arm64'}
    arch = arch_map.get(platform.machine(), 'amd64')

    if is_windows():
        return f'https://github.com/caddyserver/caddy/releases/latest/download/caddy_latest_windows_{arch}.zip'
    else:
        return f'https://github.com/caddyserver/caddy/releases/latest/download/caddy_latest_linux_{arch}.tar.gz'

CADDY_EXE = os.path.join(BIN_DIR, _caddy_exe_name())

# --- Log buffer ---
_log_buffer = []
_log_lock = threading.Lock()
MAX_LOG_LINES = 200

# --- Process handle ---
_caddy_process = None
_caddy_lock = threading.Lock()


def _append_log(line: str):
    with _log_lock:
        _log_buffer.append(line)
        if len(_log_buffer) > MAX_LOG_LINES:
            del _log_buffer[0]


def _stream_output(proc):
    """Read stdout/stderr from caddy and store in the log buffer."""
    try:
        for line in proc.stdout:
            line = line.rstrip('\n')
            print(f'[caddy] {line}')
            _append_log(line)
    except Exception:
        pass


class CaddyManager:
    """Manages the Caddy binary lifecycle and Caddyfile generation."""

    # ── Binary ──────────────────────────────────────────────

    @staticmethod
    def is_installed() -> bool:
        return os.path.isfile(CADDY_EXE)

    @staticmethod
    def download_binary():
        """Download Caddy binary from GitHub releases."""
        os.makedirs(BIN_DIR, exist_ok=True)
        url = _caddy_download_url()
        archive_path = os.path.join(BIN_DIR, 'caddy_archive')

        try:
            print(f'[caddy] Downloading from {url} …')
            urllib.request.urlretrieve(url, archive_path)

            # Extract exe/binary from archive
            if url.endswith('.zip'):
                with zipfile.ZipFile(archive_path, 'r') as z:
                    for name in z.namelist():
                        if name.endswith('.exe') or name == 'caddy':
                            with z.open(name) as src, open(CADDY_EXE, 'wb') as dst:
                                dst.write(src.read())
                            break
            else:
                import tarfile
                with tarfile.open(archive_path, 'r:gz') as t:
                    for member in t.getmembers():
                        if member.name == 'caddy' or os.path.basename(member.name) == 'caddy':
                            src = t.extractfile(member)
                            if src:
                                with open(CADDY_EXE, 'wb') as dst:
                                    dst.write(src.read())
                            break

            os.remove(archive_path)

            if not is_windows():
                st = os.stat(CADDY_EXE)
                os.chmod(CADDY_EXE, st.st_mode | stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH)

            print('[caddy] Download complete.')
            return {'success': True, 'message': 'Caddy 下載完成。'}

        except Exception as e:
            for f in [archive_path, CADDY_EXE]:
                if os.path.exists(f):
                    try:
                        os.remove(f)
                    except OSError:
                        pass
            return {'success': False, 'message': f'下載失敗：{e}'}

    # ── Caddyfile Generation ────────────────────────────────

    @staticmethod
    def generate_caddyfile(services: list) -> str:
        """
        Generate a Caddyfile from a list of service dicts.

        Each service dict should have:
          - domain  : str  (e.g. 'app.example.com')
          - target  : str  (e.g. '192.168.1.50:3000')
          - auth    : bool (True → basic auth via EZ-Portal placeholder)
        """
        os.makedirs(CADDY_GENERATED_DIR, exist_ok=True)

        lines = [
            '# Auto-generated by EZ-WebBridge',
            '# Do not edit manually — use the dashboard instead.',
            '',
        ]

        for svc in services:
            domain = svc.get('domain', '')
            target = svc.get('target', '')
            auth   = svc.get('auth', False)

            if not domain or not target:
                continue

            lines.append(f'{domain} {{')
            lines.append(f'    reverse_proxy {target}')
            if auth:
                # Caddy basic auth placeholder — to be replaced by EZ-Portal flow
                lines.append('    # EZ-Portal auth — see /auth endpoint')
            lines.append('}')
            lines.append('')

        content = '\n'.join(lines)

        with open(CADDYFILE_PATH, 'w', encoding='utf-8') as f:
            f.write(content)

        return content

    # ── Lifecycle ───────────────────────────────────────────

    @staticmethod
    def start(caddyfile: str | None = None):
        """Start Caddy using the generated Caddyfile."""
        global _caddy_process

        if not CaddyManager.is_installed():
            return {'success': False, 'message': 'Caddy 尚未安裝，請先下載。'}

        with _caddy_lock:
            if _caddy_process and _caddy_process.poll() is None:
                return {'success': True, 'message': 'Caddy 已在執行中。'}

            cfg = caddyfile or CADDYFILE_PATH
            if not os.path.isfile(cfg):
                return {'success': False, 'message': '找不到 Caddyfile，請先設定服務。'}

            try:
                proc = subprocess.Popen(
                    [CADDY_EXE, 'run', '--config', cfg],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                )
                _caddy_process = proc
                t = threading.Thread(target=_stream_output, args=(proc,), daemon=True)
                t.start()
                time.sleep(1.0)

                if proc.poll() is not None:
                    return {'success': False, 'message': 'Caddy 啟動後立即結束，請確認 Caddyfile 格式。'}

                return {'success': True, 'message': 'Caddy 已成功啟動。'}

            except Exception as e:
                return {'success': False, 'message': f'啟動失敗：{e}'}

    @staticmethod
    def stop():
        """Stop the running Caddy process."""
        global _caddy_process
        with _caddy_lock:
            if _caddy_process and _caddy_process.poll() is None:
                _caddy_process.terminate()
                try:
                    _caddy_process.wait(timeout=10)
                except subprocess.TimeoutExpired:
                    _caddy_process.kill()
                _caddy_process = None
                return {'success': True, 'message': 'Caddy 已停止。'}
            return {'success': True, 'message': 'Caddy 未在執行中。'}

    @staticmethod
    def reload():
        """Gracefully reload Caddy config without downtime."""
        global _caddy_process
        with _caddy_lock:
            if not _caddy_process or _caddy_process.poll() is not None:
                return CaddyManager.start()
        try:
            result = subprocess.run(
                [CADDY_EXE, 'reload', '--config', CADDYFILE_PATH],
                capture_output=True, text=True, timeout=15
            )
            if result.returncode == 0:
                return {'success': True, 'message': 'Caddy 設定已熱重載。'}
            return {'success': False, 'message': result.stderr or '重載失敗'}
        except Exception as e:
            return {'success': False, 'message': str(e)}

    @staticmethod
    def is_running() -> bool:
        with _caddy_lock:
            return _caddy_process is not None and _caddy_process.poll() is None

    @staticmethod
    def status() -> dict:
        running = CaddyManager.is_running()
        return {
            'installed': CaddyManager.is_installed(),
            'running': running,
            'state': 'running' if running else 'stopped',
        }

    @staticmethod
    def get_logs(last_n: int = 50) -> list:
        with _log_lock:
            return _log_buffer[-last_n:]
